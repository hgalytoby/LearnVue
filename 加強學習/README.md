# 筆記

## 1.認識 Vue
- 認識 Vue
    - New Vue 實例。
    - 認識 {{}} 差值。
    
## 2.Vue 模板語法
- 模板語法
    - 顯示訊息地方要用 data 要用 {{}}>。
    - 屬性地方要用 data 要在屬性前面加 ":"。
    - v-bind: 可以簡寫成 ":"
    - 屬性前面加了 ":"後值就會變成 Js 語法。
    
## 3.資料綁定
- 資料綁定
    - Vue中有2種數據綁定的方式: 
        - 1.單向綁定(v-bind): 資料只能從 data 流向頁面。
        - 2.雙向綁定(v-model): 資料不僅能從 data 流向頁面，還可以從頁面流向 data。
        - 備註:
            - 1.雙向綁定一般都應用在表單類元素上(如: input、select 等)
            - 2.v-model:value 可以簡寫為 v-model，因為 v-model 默認收集的就是 value 值。    
            - 3.v-model 只能應用在表單類元素(輸入類元素)上，簡單來講就是要有 value 的值。

## 4.el 與 data 的兩種寫法
- el 與 data 的兩種寫法
    - 1.el有 2 種寫法
        - (1).new Vue 時候配置 el 屬性。
        - (2).先創建 Vue 實例，隨後再通過 vm.$mount('#root') 指定 el 的值。
    - 2.data 有 2 種寫法
        - (1).對象式
        - (2).函數式
        - 如何選擇: 目前哪種寫法都可以，以後學習到組件時，data 必須使用函數式，否則會報錯。
    3.一個重要的原則:
        - 由 Vue 管理的函數，一定不要寫箭頭函數，一旦寫了箭頭函數，this 就不再是 Vue 實例了。

## 5.MVVM 模型
- MVVM 模型
    - MVVM模型
        - 1. M: 模型 (Model): data 中的數據
        - 2. V: 視圖 (View): 模板代碼
        - 3. VM: 視圖模型 (ViewModel): Vue 實例
    - 觀察發現:
        - 1.data 中所有的屬性，最後都出現在了 vm 身上。
        - 2.vm 身上所有的屬性 及 Vue 原型上所有屬性，在 Vue 模板中都可以直接使用。

## 6.資料代理
- Object.defineProperty方法
    - get 與 set 的說明。
    - enumerable: true
        - 控制屬性是否可以枚舉，默認值為 false
    - writable: true
        - 控制屬性是否可以被修改，默認值為 false
    - configurable: true
        - 控制屬性是否可以被刪除，默認值為 false
- 何為資料代理
    - 資料代理:通過一個對象代理對另一個對像中屬性的操作 (讀 / 寫)
    - 使用 Object.defineProperty 指定對象插入 key 與 value，在 console 頁面上與一般展開資料會有所不同。
- Vue 中的資料代理
    - 1.Vue 中的數據代理:
        - 通過 vm 對象來代理 data 對像中屬性的操作（讀/寫）
    - 2.Vue 中數據代理的好處:
        - 更加方便的操作 data 中的數據
    - 3.基本原理:
        - 通過 Object.defineProperty() 把 data 對像中所有屬性添加到 vm 上。
        - 為每一個添加到 vm 上的屬性，都指定一個 getter/setter。
        - 在 getter/setter 內部去操作 (讀 / 寫) data 中對應的屬性。

## 7.事件處理
- 事件的基本使用
    - 事件的基本使用:
        - 1.使用 v-on:xxx 或 @xxx 綁定事件，其中 xxx 是事件名
        - 2.事件的回調需要配置在 methods 對像中，最終會在vm上
        - 3.methods 中配置的函數，不要用箭頭函數！否則 this 就不是 vm 了
        - 4.methods 中配置的函數，都是被 Vue 所管理的函數，this 的指向是 vm 或 組件實例對象
        - 5.@click="demo" 和 @click="demo($event)" 效果一致，但後者可以傳參數
- 事件修飾符
    - Vue中的事件修飾符:
        - 前三個用的居多，後三個當作擴展了解
        - 1.prevent: 阻止默認事件(常用)
        - 2.stop: 阻止事件冒泡(常用)
        - 3.once: 事件只觸發一次(常用)
        - 4.capture: 使用事件的捕獲模式
        - 5.self: 只有 event.target 是當前操作的元素時才觸發事件
        - 6.passive: 事件的默認行為立即執行，無需等待事件回調執行完畢
        - 7.@scroll
            - 這是 scroll 滾動條的滾動
        - 8.@wheel
            - 這個是滑鼠的滾輪上下滾動會觸發，會等方法內的的程式執行完才動滾動條
- 鍵盤事件
    - 1.Vue中常用的按鍵別名:
        - 回車 => enter
        - 刪除 => delete (捕獲"刪除"和"退格"鍵)
        - 退出 => esc
        - 空格 => space
        - 換行 => tab (特殊，必須配合 keydown 去使用)
        - 上 => up
        - 下 => down
        - 左 => left
        - 右 => right
- 2.Vue未提供別名的按鍵，可以使用按鍵原始的 key 值去綁定，但注意要轉為 kebab-case (短橫線命名)
    - 英文單字如果有兩個大寫英文組成，例如: CapsLock，那就要將大寫的地方使用 "-" 並必須要全小寫。
- 3.系統修飾鍵 (用法特殊):ctrl、alt、shift、meta(win鍵)
    - (1).配合 keyup 使用: 按下修飾鍵的同時，再按下其他鍵，隨後釋放其他鍵，事件才被觸發。
    - (2).配合 keydown 使用:正常觸發事件。
        - 組合鍵 @keydown.ctrl.i
- 4.也可以使用 keyCode 去指定具體的按鍵(不推薦)
- 5.Vue.config.keyCodes.自定義鍵名 = 鍵碼，可以去客製按鍵別名

## 8.計算屬性
- 姓名案例_插值語法實現
    - 基本的教學
- 姓名案例_methods實現
    - 對比計算屬性的差別，看控制台，用 methods 寫幾次就會掉用幾次
- 姓名案例_計算屬性實現
    - 計算屬性:
        - 1.定義: 需要的屬性不存在，要通過已有的屬性計算得來。
        - 2.原理: 可以藉助 Objcet.defineproperty 提供的 getter 和 setter。
        - 3.get 函數什麼時候執行？
        - 4.優勢:與方法實現虛擬，內部有檢查機制(功能)，放大，精細方便。
        - 5.注意事項:
            - 1.計算屬性最終會在 vm 上，直接讀取使用方法。
            - 2.如果計算屬性要被修改，那必須寫設置函數去響應修改，並且設置中要計算時依賴的數據發生改變。
    - (1).首次讀取時會執行一次。
    - (2).當依賴的數據發生改變時會被再次調用。
        
- 姓名案例_計算屬性簡寫
    - 簡寫計算屬性方法
    - 只考慮讀取不考慮修改就用簡寫形式
        
## 9.監視屬性
- 天氣案例
    - 基本的教學
- 天氣案例_監視屬性
    - 監視屬性觀察:
        - 1.當被監視的屬性變化時，相關功能自動調用，進行操作
        - 2.監視的屬性必須存在，才能進行監視!!
        - 3.監視的兩種寫法:
            - (1).新的 Vue 時傳入 watch 配置
            - (2).通過 vm.$watch 監視
    - immediate: true
        - 初始化時讓 handler 調用一下
    - handler 
        - 什麼時候調用? 當 isHot 發生改變時。
        ```js
        handler(newValue, oldValue){
            console.log('修改了!', newValue, oldValue)  
        }
        ```
- 天氣案例_深度監視
    - 深度監視:
        - (1).Vue 中的觀察默認不對象內部值的改變(一層)。
        - (2).配置深度: 真實可以監測對象內部值改變(第三)。
    - deep: true
        - 開啟深度監視。
    - 備註:
        - (1).Vue 自身可以監測對象內部值的改變，但 Vue 提供的觀察默認不可以!
        - (2).使用觀察時根據資料的具體結構，決定是否採用深度監視。
- 天氣案例_深度監視_簡寫
    - 簡寫深度監視方法
    - 代價是無法寫 immediate 與 deep。
- 姓名案例_watch 實現
    - computed和 watch 之間的區別:
        - 1.computed 能完成的功能，watch 都可以完成。
        - 2.watch 能完成的功能，computed 不一定能完成，例如: watch 可以進行異步操作。
        - 3.在 computed 與 watch 中使用 setTimeout 就能知道差異了。
    - 兩個重要的小原則:
        - 1.被 Vue 管理的函數，最好寫成普通函數，這樣 this 的指向才是 vm 或 組件實例對象。
        - 2.所有不被 Vue 所管理的函數(定時器的回調函數、ajax 的回調函數等、Promise 的回調函數)，最好寫成箭頭函數，這樣 this 的指向才是 vm 或 組件實例對象。

## 10.綁定樣式
- 綁定樣式
    - 綁定 class 樣式 -- 字符串寫法，適用於: 樣式的類名不確定，需要動態指定
    - 綁定 class 樣式 -- 陣列寫法，適用於: 要綁定的樣式個數不確定、名字也不確定
    - 綁定 class 樣式 -- 對象寫法，適用於: 要綁定的樣式個數確定、名字也確定，但要動態決定用不用
    - 綁定 style 樣式 -- 對象寫法
    - 綁定 style 樣式 -- 陣列寫法
    - 屬性名稱有"-"地方要用改用大寫
        - 例如 font-size 要改成 fontSize
        
## 11.條件渲染
- 條件渲染
    - 1.v-if
        - 寫法:
            - (1).v-if="表達式"
            - (2).v-else-if="表達式"
            - (3).v-else="表達式"
        - 適用於: 切換頻率較低的場景。
        - 特點: 不展示的 DOM 元素直接被移除。
        - 注意: v-if 可以和 :v-else-if、v-else 一起使用，但要求結構不能被"打斷"。
    - 2.v-show
        - 寫法: v-show="表達式"
        - 適用於: 切換頻率較高的場景。
        - 特點: 不展示的 DOM 元素未被移除，僅僅是使用樣式隱藏掉。 
    - 3.備註: 
        - 使用 v-if 的時，元素可能無法獲取到，而使用 v-show 一定可以獲取到。
    - 4.v-if 與 template 的配合使用
        - 渲染完 template 會消失。

## 12.列表渲染 
- 基本列表
    - v-for 指令:
        - 1.用於展示列表資料
        - 2.語法: v-for="(item, index) in xxx" :key="yyy"
        - 3.可遍歷: 陣列、對象、字符串(用的很少)、指定的次數(用的很少) 
- key 的原理
    - react、vue 中的 key 有什麼作用? (key 的內部原理)
        - 1.虛擬 DOM 中 key 的作用:
            - key 是虛擬 DOM 對象的標識，當資料發生變化時，Vue 會根據[新資料]生成[新的虛擬DOM],
            - 隨後 Vue 進行[新虛擬 DOM]與[舊虛擬 DOM]的差異比較，比較規則如下:
                - (1).舊虛擬 DOM 中找到了與新虛擬 DOM 相同的 key:
                    - ①.若虛擬 DOM 中內容沒變, 直接使用之前的真實 DOM！
                    - ②.若虛擬 DOM 中內容變了, 則生成新的真實 DOM，隨後替換掉頁面中之前的真實 DOM。
                - (2).舊虛擬 DOM 中未找到與新虛擬 DOM 相同的 key
                    - 創建新的真實 DOM，隨後渲染到到頁面。
        - 2.用 index 作為 key 可能會引發的問題:
            - 1.若對資料進行: 逆序增加、逆序刪除等破壞順序操作:
                - 會產生沒有必要的真實 DOM 更新 ==> 界面效果沒問題，但效率低。
            - 2.如果結構中還包含輸入類的 DOM:
                - 會產生錯誤 DOM 更新 ==> 界面有問題。
        - 3.開發中如何選擇 key?:
            - 1.最好使用每條資料的唯一標識作為 key, 比如 id、手機號、身份證號、學號等唯一值。
            - 2.如果不存在對資料的逆序增加、逆序刪除等破壞順序操作，僅用於渲染列表用於展示，
                - 使用 index 作為 key 是沒有問題的。
- 列表過濾    
    - watch 過濾寫法            
    - computed 過濾寫法            
    - methods 過濾寫法    
    - //#region //#endregion 可以摺疊程式碼。
- 更新時的一個問題
    - 在陣列裡的 Obj，如果用 obj.xxx = val，Vue 可以監測到。
    - 在陣列裡的 Obj，如果直接把整個對象更換，Vue 無法監測到。
        - arr[0] = obj 無效
        - 用 arr.splice(x, x, obj) 有效
- Vue 監視資料改變的原理_對象
    - Vue 的 data 不管有幾層都能將 obj 的 key 賦予 get 與 set 。
    - 主要是跟 "模擬一個資料監測" 比對。
- 模擬一個資料監測
    - 模擬 Vue 的資料監測，只是簡單的並沒有很完善，但主要核心功能有了。
    - 跟 "Vue 監視資料改變的原理_對象"比對。
- Vue.set 的使用
    - vue.set 功能介紹 https://cn.vuejs.org/v2/api/index.html#Vue-set
    - 在 data 內沒有的值一開始就被模板調用的話，會報錯!就算之後用 vue.set 也無法解決問題。
    - 但如果是在 data.key.xx 這種值被一開始調用的話是不會報錯的，只是頁面上不顯示值，可以通過 vue.set 後天補值上去達成響應式作法。
    - 使用方法
        - 第一種
            ```js
            Vue.set()
            ```
        - 第二種
            ```js
            const vm = new Vue({})
            vm.$set()
- Vue 監視資料改變的原理_陣列
    - Vue 監聽陣列的介紹 https://cn.vuejs.org/v2/guide/list.html#%E5%8F%98%E6%9B%B4%E6%96%B9%E6%B3%95
    - 只有這些功能可以讓 Vue 偵測到資料變了，push()、pop()、shift()、unshift()、splice()、sort()、reverse()。
    - 使用方法
        - 第一種
            ```js
            Vue.set(vm.student.hobby, 1, '哈哈我改到了')
            ```
        - 第二種
            ```js
            const vm = new Vue({})
            vm.$set(vm.student.hobby, 1, '哈哈我改到了')
            ```
## 13.收集表單資料
- 收集表單資料:
    - 若: <input type="text"/>，則 v-model 收集的是 value 值，用戶輸入的就是 value 值。
    - 若: <input type="radio"/>，則 v-model 收集的是 value 值，且要給標籤設定 value 值。
    - 若: <input type="checkbox"/>
        - 1.沒有配置 input 的 value 屬性，那麼收集的就是 checked (勾選 or 未勾選，是布林值)
        - 2.配置 input 的 value 屬性:
            - (1) v-model 的初始值是非陣列，那麼收集的就是 checked (勾選 or 未勾選，是布林值)
            - (2) v-model 的初始值是陣列，那麼收集的的就是 value 組成的陣列
    - 備註: v-model 的三個修飾符:
        - lazy: 失去焦點再收集資料
        - number: 輸入字符串轉為有效的數字
        - trim: 輸入首尾空格過濾
## 14.過濾器
- 過濾器: 
    - 定義: 對要顯示的資料進行特定格式化後再顯示(適用於一些簡單邏輯的處理)。
    - 語法: 
        - 1.註冊過濾器: Vue.filter(name, callback) 或 new Vue{filters: {}}
        - 2.使用過濾器: {{ xxx | 過濾器名 }}  或  v-bind:屬性 = "xxx | 過濾器名"
    - 備註: 
        - 1.過濾器也可以接收額外參數、多個過濾器也可以串聯
        - 2.並沒有改變原本的資料, 是產生新的對應的資料
## 15.內置指令
- v-text 指令
    - 學過的指令:
        - v-bind	: 單向綁定解析表達式, 可簡寫為 :xxx
        - v-model	: 雙向數據綁定
        - v-for  	: 遍歷數組 / 對象 / 字符串
        - v-on   	: 綁定事件監聽, 可簡寫為 @
        - v-if 	    : 條件渲染 (動態控制節點是否存存在)
        - v-else 	: 條件渲染 (動態控制節點是否存存在)
        - v-show 	: 條件渲染 (動態控制節點是否展示)
    - v-text指令:
        - 1.作用: 向其所在的節點中渲染文本內容。
        - 2.與插值語法的區別: v-text 會替換掉節點中的內容，{{ xx }} 則不會。
- v-html 指令
    - 1.作用: 向指定節點中渲染包含 html 結構的內容。
    - 2.與插值語法的區別: 
        - (1).v-html 會替換掉節點中所有的內容，{{ xx }}則不會。
        - (2).v-html 可以識別 html 結構。
    - 3.嚴重註意: v-html 有安全性問題!!!
        - (1).在網站上動態渲染任意 HTML 是非常危險的，容易導致 XSS 攻擊。
        - (2).一定要在可信的內容上使用 v-html，永不要用在使用者送出的內容上!
- v-cloak 指令
    - v-cloak 指令(沒有值)：
        - 1.本質是一個特殊屬性，Vue 實例創建完畢並接管容器後，會刪掉 v-cloak 屬性。
        - 2.使用 css 配合 v-cloak 可以解決網速慢時頁面展示出 {{ xxx }} 的問題。
        - 備註:
            - 需要有一個伺服器提供 vue.js 並且擁有延遲幾秒後才能拿到 js 的功能。
- v-once 指令
    - 1.v-once 所在節點在初次動態渲染後，就會變成靜態內容了。
    - 2.以後資料的改變不會引起 v-once 所在結構的更新，可以用於優化性能。
- v-pre 指令    
    - 1.跳過其所在節點的編譯過程。
    - 2.可利用它跳過：沒有使用指令語法、沒有使用插值語法的節點，會加快編譯。   
     
## 16.自定義指令
- 自定義指令
    - 需求1: 定義一個 v-big 指令，和 v-text 功能類似，但會把綁定的數值放大 10 倍。
    - 需求2: 定義一個 v-fbind 指令，和 v-bind 功能類似，但可以讓其所綁定的 input 元素默認獲取焦點。
    - 自定義指令總結: 
        - 一、定義語法: 
            - (1).局部指令: 
                ```js
                new Vue({															
                    directives:{指令名: 配置對象}
                }) 
                ```
                or 				
                ```js
                new Vue({
                    directives{指令名: 回調函數}
                })
                ```
            - (2).全局指令: 
                - Vue.directive(指令名, 配置對象) 或 Vue.directive(指令名, 回調函數)
        - 二、配置對像中常用的 3 個回調:
            - (1).bind: 指令與元素成功綁定時調用。
            - (2).inserted: 指令所在元素被插入頁面時調用。
            - (3).update: 指令所在模板結構被重新解析時調用。
        - 三、備註: 
            - 1.指令定義時不加 v-，但使用時要加 v-；
            - 2.指令名如果是多個單詞，要使用 kebab-case 命名方式，不要用 camelCase 命名。
- 回顧一個DOM操作
    - 演示原生 js focus 的流程。

## 17.生命週期  
- 1.引出生命週期
    - 生命週期: 
        - 1.又名: 生命週期回調函數、生命週期函數、生命週期鉤子。
        - 2.是什麼: Vue 在關鍵時刻幫我們調用的一些特殊名稱的函數。
        - 3.生命週期函數的名字不可更改，但函數的具體內容是程式員根據需求編寫的。
        - 4.生命週期函數中的 this 指向是 vm 或 組件實例對象。
- 2.分析生命週期
    - 8個生命週期範例。
    - template
        - 會將 el 整個替換掉，所以後面帶的元素都會消失。
        - 範例: x 會消失。
            ```html
            <div id="root" x:n></div>
            ```
- 3.總結生命週期
    - 常用的生命週期鉤子：
        - 1.mounted: 發送ajax請求、啟動定時器、綁定自定義事件、訂閱消息等【初始化操作】。
        - 2.beforeDestroy: 清除定時器、解綁自定義事件、取消訂閱消息等【收尾工作】。
    - 關於銷毀 Vue實例
        - 1.銷毀後藉助 Vue 開發者工具看不到任何訊息。
        - 2.銷毀後自定義事件會失效，但原生 DOM 事件依然有效。
        - 3.一般不會在 beforeDestroy 操作數據，因為即便操作數據，也不會再觸發更新流程了。
    
## 18.非單文件組件
- 1.基本使用  
    - Vue 中使用組件的三大步驟: 
        - 一、定義組件(創建組件)
        - 二、註冊組件
        - 三、使用組件(寫組件標籤)
    - 一、如何定義一個組件？
        - 使用 Vue.extend(options) 創建，其中 options 和 new Vue(options) 時傳入的那個 options 幾乎一樣，但也有點區別
        - 區別如下:
                - 1.el 不要寫，為什麼？ ——— 最終所有的組件都要經過一個 vm 的管理，由 vm 中的 el 決定服務哪個容器。
                - 2.data 必須寫成函數，為什麼？ ———— 避免組件被重複使用時，資料存在引用關係。
        - 備註: 使用 template 可以配置組件結構。
    - 二、如何註冊組件?
        - 1.局部註冊: 靠 new Vue 的時候傳入 components 選項
        - 2.全局註冊: 靠 Vue.component('組件名', 組件)
    - 三、編寫組件標籤: 
        - <school></school>
- 2.幾個注意點  
    - 1.關於組件名:
        - 一個單詞組成: 
            - 第一種寫法 (首字母小寫): school
            - 第二種寫法 (首字母大寫): School
        - 多個單詞組成: 
            - 第一種寫法 (kebab-case命名): my-school
            - 第二種寫法 (CamelCase命名): MySchool (需要Vue腳手架支持)
        - 備註: 
            - (1).組件名盡可能迴避 HTML 中已有的元素名稱，例如: h2、H2都不行。
            - (2).可以使用 name 配置項指定組件在開發者工具中呈現的名字。
    - 2.關於組件標籤:
        - 第一種寫法: <school></school>
        - 第二種寫法: <school/>
        - 備註: 不用使用腳手架時，<school/>會導致後續組件不能渲染。
    - 3.一個簡寫方式:
        - const school = Vue.extend(options) 可簡寫為: const school = options
- 3.組件的嵌套  
    - 正常的流程由最外層一個組件去管理所有的組件。